generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             Int            @id @default(autoincrement())
  name           String?
  email          String         @unique
  image          String?
  role           Role           @default(USER)
  bio            String?
  profileImage   String?
  emailVerified  DateTime?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  submissions    SongSubmission[] @relation("SubmissionSubmitter")
  reviews        SongSubmission[] @relation("SubmissionReviewer")
  favorites      Favorite[]
  stars          Star[]
  playlists      Playlist[]
  playlistItems  PlaylistItem[]
  auditLogs      AuditLog[]
  banners        Banner[]       @relation("BannerCreator")
  versions       SongVersion[]  @relation("VersionAuthor")
  moderation     UserModeration?
  moderationHistory ModerationHistory[] @relation("UserHistory")
  moderatedUsers UserModeration[] @relation("ModerationModerator")
  moderationActions ModerationHistory[] @relation("ModeratorHistory")
}

model UserModeration {
  id           Int            @id @default(autoincrement())
  userId       Int            @unique
  status       ModerationStatus @default(ACTIVE)
  type         ModerationType?
  reason       String?
  moderatorNote String?
  ipAddress    String?
  moderatedById Int?
  moderatedAt  DateTime?
  expiresAt    DateTime?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  moderatedBy  User?          @relation("ModerationModerator", fields: [moderatedById], references: [id])
  
  @@index([ipAddress])
  @@index([status])
}

model ModerationHistory {
  id           Int            @id @default(autoincrement())
  userId       Int
  status       ModerationStatus
  type         ModerationType?
  reason       String?
  moderatorNote String?
  ipAddress    String?
  moderatedById Int?
  moderatedAt  DateTime       @default(now())
  expiresAt    DateTime?
  createdAt    DateTime       @default(now())
  user         User           @relation("UserHistory", fields: [userId], references: [id], onDelete: Cascade)
  moderatedBy  User?          @relation("ModeratorHistory", fields: [moderatedById], references: [id])
  
  @@index([userId])
  @@index([moderatedAt])
  @@index([status])
}

model Song {
  id               String             @id @default(cuid())
  title            String
  moments          LiturgicalMoment[]
  type             SongType
  mainInstrument   Instrument
  tags             String[]
  currentVersionId String?            @unique
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  slug             String             @unique
  favorites        Favorite[]
  stars            Star[]
  playlistItems    PlaylistItem[]
  currentVersion   SongVersion?       @relation("CurrentVersion", fields: [currentVersionId], references: [id])
  versions         SongVersion[]
}

model SongVersion {
  id            String     @id @default(cuid())
  songId        String
  versionNumber Int
  sourceType    SourceType
  sourcePdfKey  String?
  sourceText    String?
  renderedHtml  String?
  keyOriginal   String?
  lyricsPlain   String
  chordsJson    Json?
  abcBlocks     Json?
  mediaUrl      String?
  spotifyLink   String?
  youtubeLink   String?
  approvedAt    DateTime?
  createdAt     DateTime   @default(now())
  createdById   Int
  currentOf     Song?      @relation("CurrentVersion")
  createdBy     User       @relation("VersionAuthor", fields: [createdById], references: [id])
  song          Song       @relation(fields: [songId], references: [id])
}

model SongSubmission {
  id              String             @id @default(cuid())
  title           String
  moment          LiturgicalMoment[]
  type            SongType
  mainInstrument  Instrument
  tags            String[]
  submitterId     Int
  status          SubmissionStatus   @default(PENDING)
  rejectionReason String?
  tempSourceType  SourceType
  tempPdfKey      String?
  tempText        String?
  parsedPreview   Json?
  mediaUrl        String?
  spotifyLink     String?
  youtubeLink     String?
  createdAt       DateTime           @default(now())
  reviewedAt      DateTime?
  reviewerId      Int?
  reviewer        User?              @relation("SubmissionReviewer", fields: [reviewerId], references: [id])
  submitter       User               @relation("SubmissionSubmitter", fields: [submitterId], references: [id])
}

model Favorite {
  userId    Int
  songId    String
  createdAt DateTime @default(now())
  song      Song     @relation(fields: [songId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@id([userId, songId])
}

model Star {
  userId    Int
  songId    String
  createdAt DateTime @default(now())
  song      Song     @relation(fields: [songId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, songId])
}

model Playlist {
  id          String         @id @default(cuid())
  name        String
  description String?
  isPublic    Boolean        @default(false)
  userId      Int
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  items       PlaylistItem[]

  @@index([userId])
  @@index([isPublic])
}

model PlaylistItem {
  id         String   @id @default(cuid())
  playlistId String
  songId     String
  order      Int
  addedById  Int
  createdAt  DateTime @default(now())
  playlist   Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  song       Song     @relation(fields: [songId], references: [id], onDelete: Cascade)
  addedBy    User     @relation(fields: [addedById], references: [id], onDelete: Cascade)

  @@unique([playlistId, songId])
  @@index([playlistId, order])
}

model AuditLog {
  id        Int      @id @default(autoincrement())
  userId    Int?
  action    String
  entity    String?
  entityId  String?
  metadata  Json?
  createdAt DateTime @default(now())
  user      User?    @relation(fields: [userId], references: [id])
}

model Banner {
  id          String         @id @default(cuid())
  title       String
  message     String
  type        BannerType
  position    BannerPosition @default(TOP)
  pages       BannerPage[]
  isActive    Boolean        @default(true)
  priority    Int            @default(0)
  startDate   DateTime?
  endDate     DateTime?
  createdById Int
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  createdBy   User           @relation("BannerCreator", fields: [createdById], references: [id])
}

enum Role {
  USER
  TRUSTED
  REVIEWER
  ADMIN
}

enum ModerationStatus {
  ACTIVE
  WARNING
  SUSPENDED
  BANNED
}

enum ModerationType {
  WARNING
  SUSPENSION
  BAN
}

enum SubmissionStatus {
  PENDING
  APPROVED
  REJECTED
}

enum SourceType {
  PDF
  MARKDOWN
}

enum SongType {
  ACORDES
  PARTITURA
}

enum Instrument {
  ORGAO
  GUITARRA
  PIANO
  CORO
  OUTRO
}

enum LiturgicalMoment {
  ENTRADA
  ATO_PENITENCIAL
  GLORIA
  SALMO
  ACLAMACAO
  OFERTORIO
  SANTO
  COMUNHAO
  ACAO_DE_GRACAS
  FINAL
  ADORACAO
  ASPERSAO
  BAPTISMO
  BENCAO_DAS_ALIANCAS
  CORDEIRO_DE_DEUS
  CRISMA
  INTRODUCAO_DA_PALAVRA
  LOUVOR
  PAI_NOSSO
  REFLEXAO
  TERCO_MISTERIO
}

enum BannerType {
  ANNOUNCEMENT
  ALERT
  CHANGELOG
  WARNING
  REQUEST
  INFO
  SUCCESS
  ERROR
}

enum BannerPosition {
  TOP
  BOTTOM
}

enum BannerPage {
  HOME
  MUSICS
  ADMIN
  ALL
}
